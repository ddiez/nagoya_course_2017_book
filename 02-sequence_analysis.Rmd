# Sequence analysis

This chapter introduces the basics of sequence analysis methods. As mentioned in Section \@ref(intro-sequence-analysis) ([Sequence analysis](intro-sequence-analysis)), the main goal of sequence analysis is two answer questions regarding DNA, RNA and/or protein sequences. For example, we could be presented with an unknown sequence, like the one shown here:

```
MTEYKLVVVGAGGVGKSALTIQLIQNHFVDEYDPTIEDSYRKQVVIDGETCLLDILDTAG
QEEYSAMRDQYMRTGEGFLCVFAINNTKSFEDIHHYREQIKRVKDSEDVPMVLVGNKCDL
PSRTVDTKQAQDLARSYGIPFIETSAKTRQRVEDAFYTLVREIRQYRLKKISKEEKTPGC
VKIKKCIIM
```

Since we only have the amino acid sequence, the first thing we may want to do is to compare these sequence with the sequence of other proteins in order to see whether we find other proteins that look similar. The process of comparing two sequences to figure out their similarity is called sequence alignment.

## Pairwise alignment

Imagine we could find a known protein for which 100% of its amino acid sequence is identical with our unknown sequence. Then we could say we have identified our protein! Imagine however that not all the amino acids are exactly identical. At some positions we may have some changes. The more changes we have, the more disimilar the two sequences will be. We want a way to quantitatively measure how much different (or similar) two sequences are. This is represented below by the two DNA sequences (seq1 and seq2) which are put together. The sequence of dots and asteriks below indicates whether the two aminoacids aligned are identical (and then is a `.`) or different (and then is a `*`).

```
seq1 A A G G A T G A
seq2 A A C G A T A A
     . . * . . . * .
```

It is possible for the sequences to not be the same lengths. In that situation the residue positions not matching to any other residue in the other sequence are indicated with the gap symbol `-`. Gaps, however, may appear also when comparing sequences of the same length.

```
seq3 A A G G A T G G A
seq2 A A C G A T A - A
     . . * . . . * * .
```

When aligning two sequences we need to specify a scoring system. This is a matrix with a score proportional to the probability of the change in residue happening. A simple scoring system could be the following: +1 when the two residues are the same, -1 otherwise:

```{r, echo=FALSE, comment=NA}
r <- c("A", "G", "T", "C")
m <- matrix(-1, ncol = 4, nrow = 4, dimnames = list(r, r))
diag(m) <- 1
m
```

If we consider this scoring system, the score of the following alignment can be calculated using the information in the scoring matrix. In the following example `+` indicates the +1 score and `-` the -1 score.

```
seq1 A A G G A T G A 
seq2 A A C G A T A A
     + + - + + + - +

score: 6 * (+1) + 2 * (-1) = +4
```

When there are gaps, a score for the gap needs to be specified. For example, we could use a score of -1 and the score of the gapped alignment above can be computed accordingly.

```
seq3 A A G G A T G G A
seq2 A A C G A T A - A
     + + - + + + - - +

score: 6 * (+1) + 3 * (-1) = +3
```

Different alignments will produce different scores. For example, we could have aligned the `seq3` and `seq2` in a different way.

```
seq3 A A G G A T G G A
seq2 A A C G A T A A -
     + + - + + + - - -

score: 5 * (+1) + 4 * (-1) = +1
```

This alignment produces a smaller score and therefore is not as optimal as the original one. The goal of sequence alignment algorithms is to find the optimal alignment, that is, the aligment that maximizes the score. It is important to notice that sometimes there is *best* alignment. For example, consider this alternative alignment.

```
seq3 A A G G A T G G A
seq2 A A C G A T - A A
     + + - + + + - - +

score: 6 * (+1) + 3 * (-1) = +3
```

There is a slight difference in where the second-to-last `A` in `seq2` is located. Both alternatives produce the same score, so there is no way to know which one is the best.

There are two main methods to perform sequence alignment: global and local. In global alignment the two sequences are aligned along their entire lengths, and the best alignment is returned. This means every residue of a sequence is aligned to a residue of the other sequence or to a gap. In local alignment the best subsequence alignment is found. Global alignment is used to compare two sequences end-to-end, whereas local alignment is used to identify the parts of the sequences that are most similar.



For example, using the scoring system above, we can compute the result from global and local aligment for `seq2` and `seq3` using the Biostrings package in Bioconductor:

```{r, echo=FALSE, comment=NA}
Biostrings::pairwiseAlignment(
  "AAGGATGGA",
  "AACGATAA",
  type = "global",
  substitutionMatrix = m,
  gapOpening = 1,
  gapExtension = 0
  )
Biostrings::pairwiseAlignment(
  "AAGGATGGA",
  "AACGATAA",
  type = "local",
  substitutionMatrix = m,
  gapOpening = 1,
  gapExtension = 0
  )
```

Global aligment is alse called [Needleman-Wunsch](https://en.wikipedia.org/wiki/Needleman–Wunsch_algorithm) whereas local aligment is called [Smith-Waterman](https://en.wikipedia.org/wiki/Smith–Waterman_algorithm). You can see more details regarding how these two algorithms work in their wikipedia pages.

## Scoring matrices

In reality we do not use a scoring matrix like the one above. We want to use scoring matrices that reflect how residue changes (whether amino acid or nucleotide) occur in nature. For protein sequences there are two main types of matrices used typically in sequence aligments: BLOSUM and PAM.

BLOSUM stands for BLOcks SUbstitution Matrix. BLOSUM matrices are empirical, derived from local aligment of protein sequenes found in databases (originally in the BLOCKS database). The matrix number indicates the selection process for including sequences into the computatiom. For example, the BLOSUM62 matrix includes aligments of sequences with less than 62% similarity. A fragment of the BLOSUM62 matrix is shown below.

```{r, echo=FALSE, comment=NA}
data("BLOSUM62", package = "Biostrings")
BLOSUM62[1:10, 1:10]
```

As you can see the diagonal contains positive scores (e.g. A->A score 4), indicating that identity is highly favored. Not all scores in the diagonal are equal. This reflects that some identities are more strongly enforced that others. For example, the score for D->D is 6, indicating that this identity happens more frequently than A->A. This probably reflect the fact that an A can be replaced by more amino acids without causing a big disruption in the structure than if the change involves a D. Some of the positions are 0, and some others are negative, indicating non-favorable substitutions. For example, the change E->C has a score of -4 indicating that it doesn't happen often, probably because is not favored.

An alternative to the BLOSUM matrices are the [PAM matrices](https://en.wikipedia.org/wiki/Point_accepted_mutation).

## Blast

Searching for similar sequences in a large sequence database can be computationally expensive because the SW algorithm is relativelly slow. Therefore, some alternatives to it have been developed over the years. One such alternative is Blast.

Blast stands for Basic Local Alignment Tools. Blast uses some heuristics to improve the speed of the local alignment and therefore can be used to search for large sequence databases. Often the quality of the alignment is as good as the one we could obtain with SW. However, it is possible to loose some accuracy.

## Multiple sequence alignment

When we want to align 3 o more sequences together we have a multiple sequence alignment (MSA). In MSA there is more ambiguity in what determines a correct alignment.

Software for MSA:

* MAFFT
* Clustal (Classic)
* MUSCLE

## Domains and motifs

Biological sequences contain regions of high similarity to other similar regions in other proteins. Sometimes this regios are small, accounting for a few aminoacids, and they are typically named *motifs*. In other cases the conserved regions are larger, and then are called *domains*. Domains are sometimes associated with some structurally motivated definition of domain. Sometimes however, the distinction between these two types of conserved regions is ambigous.

Motifs and domains can be identified by using the information from a MSA. This is the approach followed in the Pfam database. Sections of MSAs containing the domain of interest are manually curated. These are used to train a Hidden Markov Model (HMM) that learns how to recognize the same domain in other sequences. With that model, we can identify all sequences in a database containing that particular domain.

The software HMMER implements HMM for the analysis of biological sequences. It can learn models representing motifs, domains or entire sequences. These models are used to search for sequences matching the models in databases. It can also be used to annotate the domains/motifs present in a sequence using a database of domains. PFAM uses HMMER and manually curated MSA of domains to generate a database of protein families (PFAM).

## Phylogenetic methods
